/**
 * Event listener for install event
 */
self.addEventListener('install', () => {
	// Call to ensure service worker is correctly updated
	self.skipWaiting();
});

/**
 * Event listener for activate event
 */
self.addEventListener('activate', event => {
	event.waitUntil(self.clients.claim());
});

/**
 * Event listener for push event
 */
self.addEventListener('push', event => {
	if (typeof event.data === 'undefined') {
		return;
	}

	let pushData;
	try {
		pushData = event.data.json();
	} catch {
		event.waitUntil(self.registration.showNotification(event.data.text()));
		return;
	}

	// Handle dismiss action
	if (pushData.action === 'dismiss') {
		event.waitUntil(handleDismissNotifications(pushData.notifications));
		return;
	}

	// Handle regular notification display
	let itemId = pushData.item_id || 0;
	let typeId = pushData.type_id || 0;
	let userId = pushData.user_id || 0;
	let notificationVersion = parseInt(pushData.version, 10) || 0;
	let pushToken = pushData.token || '';

	event.waitUntil((async () => {
		const getNotificationUrl = '{{ U_WEBPUSH_GET_NOTIFICATION }}';
		const assetsVersion = parseInt('{{ ASSETS_VERSION }}', 10);

		// Force update if versions differ
		if (assetsVersion !== notificationVersion) {
			await self.registration.update();
		}

		const formData = new FormData();
		formData.append('item_id', itemId.toString(10));
		formData.append('type_id', typeId.toString(10));
		formData.append('user_id', userId.toString(10));
		formData.append('token', pushToken);

		try {
			const response = await fetch(getNotificationUrl, {
				method: 'POST',
				headers: {
					'X-Requested-With': 'XMLHttpRequest',
				},
				body: formData,
			});

			const responseData = await response.json();

			const responseBody = responseData.title + '\n' + responseData.text;
			const notificationTag = typeId + '_' + itemId;
			const options = {
				body: responseBody,
				data: responseData,
				icon: responseData.avatar.src,
				tag: notificationTag,
			};

			await self.registration.showNotification(responseData.heading, options);
		} catch (e) {
			console.error('Push error:', e);
		}
	})());
});

/**
 * Event listener for notification click
 */
self.addEventListener('notificationclick', event => {
	event.notification.close();
	if (typeof event.notification.data !== 'undefined') {
		event.waitUntil(self.clients.openWindow(event.notification.data.url));
	}
});

/**
 * Handle dismiss notifications pushed from the server
 *
 * @param {Array} notifications Array of notifications to dismiss
 * @returns {Promise<void>}
 */
async function handleDismissNotifications(notifications) {
	if (!notifications || !Array.isArray(notifications) || notifications.length === 0) {
		return;
	}

	try {
		// Close each notification by its tag
		for (const dismissed of notifications) {
			const tag = dismissed.type_id + '_' + dismissed.item_id;

			// Get and close notifications with this specific tag
			const matchingNotifications = await self.registration.getNotifications({ tag: tag });
			for (const notification of matchingNotifications) {
				notification.close();
			}
		}
	} catch (e) {
		console.error('Error dismissing notifications:', e);
	}
}
